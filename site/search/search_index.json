{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Data Engineering - 101 Author : Kushal Luthra repo url : https://github.com/kushal-luthra/data-engineering-101","title":"Home"},{"location":"#welcome-to-data-engineering-101","text":"Author : Kushal Luthra repo url : https://github.com/kushal-luthra/data-engineering-101","title":"Welcome to Data Engineering - 101"},{"location":"aboutme/","text":"About me Kushal is currently Lead Engineer at Airtel Africa Digital Labs (BigData & Analytics Team). He is the Lead for Business Intelligence product, which is being built from scratch, and is aimed to be scalable (handles data that can be in Gigabytes and Terabytes) and replicable across 14 OpCos. He has extensive experience that spans across various technologies, including Python, Spark(PySpark), SQL, Hive, Hadoop, Apache Hudi, Airflow, Sqoop, Gitlab, BItBucket, CICD. He also has experience of migrating Data Solutions on legacy system to Big Data Stack. He has built data pipelines from scratch, with focus on data frameworks. Domain : Retail and Telecom Distributed Computing: Hadoop, HDFS, Yarn, Spark Programming Languages: Python, Scala Operating System: Linux, Unix Development Tools: JIRA Databases: Postgres, MongoDB, Oracle Exadata Methodologies: Agile/Scrum Open to hearing about exciting information/opportunities in meaningful industries, more tech connections and both mentor/mentee relationships.","title":"About Me"},{"location":"SQL/docs/sql_performance_tuning/","text":"SQL Performance Tuning : Summary Tip 1: Never use *(Star) to fetch all records from table Sql query become fast if you use actual columns instead of * to fetch all the records from the table. Not Recommended - Select * from Employee; Recommended Select Eno,Ename,Address from Employee; Tip 2: Try to avoid DISTINCT keyword from the query Try to avoid DISTINCT keyword from select statements. DISTINCT keyword has high cost and low performance. When anyone uses DISTINCT keyword, it first SORTS the data from column and then fetches the distinct values. Use EXISTS operator instead of DISTINCT keyword. Not Recommended: SELECT DISTINCT d.dept_no, d.department_name FROM Department d,Employee e WHERE d.dept_no= e.dept_no; Recommended: SELECT d.dept_no, d.department_name FROM Department d WHERE EXISTS ( SELECT \u2018X\u2019 FROM Employee e WHERE d.dept_no= e.dept_no); Tip 3: Carefully use WHERE conditions in sql Try to use correct operator as per requirement given. Not Recommended: Select * from Employee WHERE salary != 65000; Recommended: Select * from Employee WHERE salary > 65000 and salary < 65000; Tip 4: Use Like operator instead of equal to (=) Not Recommended: Select * from Employee where name=\u2019Amit\u2019; Recommended: Select * from Employee where name like \u2018Amit%\u2019; Tip 5: Avoid HAVING clause/GROUP BY statements HAVING clause and GROUP BY statements have high cost. So try to avoid it in sql query. Not Recommended - Select * from Employee WHERE name=\u2019Amit\u2019 GROUP BY department HAVING salary=45000; Recommended - Select * from Employee WHERE name=\u2019Amit\u2019 and salary=45000; More added: - Having clause- We use Having clause to eliminate some of the group values. Issue \u2013 Having clause restricts the rows AFTER they are read. So if no restriction in \u201cwhere clause\u201d, optimizer will use full table scan. This is really important coz all predicates in the HAVING Clause will not be used as access predicates. So they will not make optimizer use indexes, partitions etc. This is because to perform HAVING clause, it first reads all the rows and then eliminates unnecessary rows. Tip 6: Use of EXISTS and IN Operators Basically, Operator IN has lowest performance. IN operator is used when Filter criteria is in subquery, whereas EXISTS operator is used when filter criteria is in main query. Example: IN Operator Select * from Employee where Department_name IN ( Select Department_name from Department where Dno=10); Exist operator Select * from Employee where EXISTS ( Select Department_name from Department where Dno=10); More added When you run a query with IN clause, database will process it in below format \u2013 That is, in case of use of IN clause, each value of sub query is joined with outer query. Treats below Query - select * from T1 where x in (select x from T2); as - select * from t1, (select x from t2) T2 where t1.x = t2.x; But when you use EXIST clause, database will exit as soon as it gets the first match . So, in case of EXIST clause it runs executes query in below format \u2013 Treats below query - select * from T1 where exists (select x from T2 where t1.x=t2.x); as - FOR x IN (select * from t1) LOOP IF (EXISTS ( SELECT X FROM T2) ) THEN OUTPUT THE RECORD END IF; END; That is, using EXIST clause will imply database will run it like a FOR loop and as soon as match is found, it moves to next record. So which one is faster \u2013 IN or EXIST? a. This totally depends on situation. Use IN when - outer table = Big and Subquery = Small Use EXISTS when \u2013 outer table = Small and Subquery = Big b. Even above rules are not fixed. For example, if subquery has bigger table, but it has an index, in this case use of IN is suggested. c. So- EXISTS doesn\u2019t work better than IN all the times. IN is better than EXISTS if \u2013 outer table = Big and Subquery = Small outer table = Small and Subquery = Big + Indexed NOT EXISTS vs NOT IN \u2022 NOT EXISTS is not equivalent of NOT IN. \u2022 NOT EXISTS cannot be used instead of NOT IN all the times. \u2022 More specifically, if there is any NULL value in your data, they will show different result. \u2022 If your subquery returns even one NULL value, NOT IN will not match any rows. \u2022 On other hand, if you have a chance to use NOT EXISTS instead of NOT IN, you should test it. \u2022 In most database versions of oracle, EXISTS and IN are treated similarly in terms of execution plan. Tip 7: Try to use UNION ALL instead of UNION UNION scans all data first and then eliminate duplicate so it has slow performance. Not Recommended Select * from Employee where dept_no=10 UNION Select * from Employee where dept_no=20; Recommended Select * from Employee where dept_no=10 UNION ALL Select * from Employee where dept_no=20; Tip 8: Avoid use of Functions in Where condition. Not Recommended Select * from Employee where Substr(name,1,3)=\u2019Ami\u2019; Recommended Select * from Employee where name like \u2018Ami%\u2019; Tip 9: convert OR to AND If we use OR clause, it will PREVENT index usages. Instead, we should use AND where possible. Not Recommended select * from sales where prod_id = 13 or promo_id=14; Recommended select * from sales where prod_id = 13 UNION All select * from sales where promo_id=14 AND prod_id <> 13; Tip 10: Subquery Unnesting Nested queries are very costly, and so transformer tries to convert them to equivalent join statements. Not Recommended select * from sales where cust_id IN (select cust_id from customers); Recommended select sales.* from sales, customers where sales.cust_id=customers.cust_id; Tip 11: IN and BETWEEN select * from employees where emp_id in (2,3,4,5); The above is equivalent to select * from employees where emp_id = 2 OR emp_id=3 OR emp_id=4 OR emp_id=5 ---this implies full table scan. Solution - select * from employees where emp_id between 2 and 5; Tip 12: Fetching first N records Suppose we want to see only 10 records in our select statement output. There are 2 ways to do this \u2013 Using rownum (Recommended) SELECT * FROM EMPLOYEE where rownum<11; Using fetch first (not recommended) SELECT * FROM EMPLOYEE FETCH FIRST 10 ROWS ONLY; In case of rownum- Here it reads first 10 rows use count STOPKEY operator, and so faster than fetch first method. In case of fetch first \u2013 Here we read whole table, and then applied a windowing function to select 1st 10 records. Tip 13: UNION vs UNION ALL: UNION \u2013 combines data and drops duplicate rows. UNION ALL \u2013 combines data and retains duplicate rows. Suggest: Some key points- \u2022 by default, UNION ALL is less costly than UNION, as latter sorts data internally to remove duplicates. \u2022 But if your table is indexed, then sort operation in UNION wont be that costly, and so you can use UNION also. So \u2013 - Use UNION if table is indexed and you don\u2019t want duplicates in output. - Use UNION ALL if\u2013 - There is no duplicate in your data, or - You are ok with having duplicate data in output. - But overall, UNION ALL gives better performance than UNION. Tip 14: INTERSECT Vs EXISTS operator Intersect gives common rows of 2 intersection in a Sorted order. As part of intersect, 2 rows sources are first sorted, and then common records are fetched. In place of INTERSECT operator, we should try and use EXISTS clause, which is more efficient. One caveat is that, in case of EXISTS clause, output is not sorted, unlike in case of INTERSECT clause. Not Recommended SELECT employee_id FROM employees where employee_id between 145 and 179 INTERSECT SELECT employee_id FROM employees WHERE first_name LIKE 'A%'; Recommended SELECT employee_id FROM employees e where employee_id between 145 and 179 and exists (SELECT employee_id FROM employees t WHERE first_name LIKE 'A%' and e.employee_id = t.employee_id); Tip 15: MINUS Vs NOT EXISTS MINUS operator eliminates matched rows of 1st (with 2nd) and returns rest of the rows of 1st. NOT EXISTS clause can also do same work as MINUS, but has much better performance. Not Recommended SELECT employee_id FROM employees where employee_id between 145 and 179 MINUS SELECT employee_id FROM employees WHERE first_name LIKE 'A%'; Recommended SELECT employee_id FROM employees e where employee_id between 145 and 179 and not exists (SELECT employee_id FROM employees t WHERE first_name LIKE 'A%' and e.employee_id = t.employee_id); Tip 16: Using Like conditions To enable use of indexes, avoid use of wild card character at beginning of source text scan. If you are forced to use wild card character at beginning, you can create reverse index, and handle that problem using that index. In this case, when you reverse index, then source text will eliminate use of wild card at beginning. Eg \u2013 Suppose you want to find records where last name ends is \u201chhar\u201d, then create reverse() index on last_name to reverse it and then use condition where reversed last name begins with \u201crahh\u201d. Though reverse() index usage will have cost, but if your column is selective enough, it wont be much cost. Tip 17: Using Functions on Indexed Columns will suppress index usage. Use of function on indexed column will suppress index usage. So, rewrite query to avoid use of function. BAD QUERY select employee_id, first_name, last_name from employees where trunc(hire_date,'YEAR') = '01-JAN-2002'; GOOD: rewritten query select employee_id, first_name, last_name from employees where hire_date between '01-JAN-2002' and '31-DEC-2002'; Eg2 - Bad select * from mytable where substr(emp_name,1,2) = 'Po'; Good select * from mytable where emp_name like 'Po%'; Note - In Spark, we have HashAggregates and SortAggregates. Hash Aggregates are more performant, and work only on mutable data types. That is, if all elements in your Select clause (except those in Group by clause) are mutable types like INT, FLOAT, etc, then spark will use Hash Aggregates. This means, sometimes, for performance gain, we need to apply Function to transform values. See #14 at below link for details https://github.com/kushal-luthra/spark-development/blob/master/notes/spark_opimization.md Tip 18: Handling NULL Values Failing to deal with NULL values will lead to unintentional results or performance losses. Why - \u2022B-Tree indexes do not index NULL values. \u2022If there are any NULL values in your indexed columns and you need to get rows which have NULL values, optimizer will not use your index, and perform a full table scan instead. \u2022That is, having Null values in your index may sometimes suppress index usage. Ways to handle NULL value-based performance loss a. Use IS NOT NULL condition in your WHERE clause. Use IS NOT NULL condition in your WHERE clause if you don\u2019t need to have NULL values in result set. That is, even if you now your result will not be having any NULL values, you should use \u201cis not null \u201c clause to make optimizer use indexes. Eg \u2013 Query 1: select emp_name, emp_id from employee where emp_id <> 1; Query 2: select emp_name, emp_id from employee where emp_id <> 1 and emp_id is not null; In query 1, we will see FULL Table scan and in case of query 2, we see index-based scan, and lower query cost. b. Adding not null constraint to your columns and insert a specific value for NULL values like \u20180\u2019 if value in a column is null. c. If reasonable, create a BITMAP index instead of B-Tree index. BITMAP indexes store NULL values. So even if there are null values in our column, optimizer will be able to use our indexes. However, you need to take into consideration index efficiency between B-Tree and BITMAP, as former as more efficient than latter. - We use BITMAP indexes when \u2013 cardinality is LOW and index not modified often. - We use B-Tree index when \u2013 cardinality/selectivity is high. Tip 19 : Use Truncate instead of Delete Truncate is always faster than DELETE command. This is because when you run delete command, oracle database generates lots of UNDO data for deleted rows and generating UNDO data is an expensive operation. Truncate doesn\u2019t generate UNDO Data. But before using Truncate command, there are few things to note about it- \u2022 No rollback \u2013 Truncate operation cannot be rollbacked, and Flashback is also not so easy after truncate operations. You may need to use Flashback Data Archive or some other external tools in this case. \u2022 Truncate is a DDL operation \u2013 So when you run Truncate, your transaction will be committed. It performs commit before and after Truncate operation. Since it does 2 commits, and even if truncate operation fails in between, the changes you did before will be permanent in any case. \u2022 Truncate a partition - We don\u2019t need to truncate whole table all the times. You can truncate partition as well. \u2022 Truncate doesn\u2019t fire DML triggers - So you wont be able to log your truncate operation because of that. But it can fire the DDL triggers. \u2022 Truncate makes unusable indexes usable again. But delete does not. Tip 20: Data Type Mismatches If data types of column and compared value dont match, this may suppress index usage. select cust_id, cust_code from customers where cust_code = 101; Vs select cust_id, cust_code from customers where cust_code = '101'; Tip 21: Tuning Ordered queries- Order By clause Order by mostly requires SORT operations . This sort operation is done in PGA or in disk (if PGA doesn\u2019t have enough memory) This disk is shown as \u2018temporary table space\u2019 in execution plan. Issue \u2013 sorting in disk is a costly operation. Solution \u2013 \u2022 Create a B-Tree index on column used in Order by Clause, or \u2022 Modify a B-Tree index to include column used in Order by Clause. \u2022 Why\u2013> B-Tree indexes store columns in Order and using B-Tree index will eliminate sort operations. Tip 22 : Retrieving MIN and MAX Values B-Tree indexes increase the performance a lot for min and max value searches. If no B-Tree index, optimizer will need to read whole table. If our query has another column or another aggregate function in your query, it will be reading whole index or whole table. For example- When you see below, if we are looking for min() and max() values individually, output is just 2 for each. But when we want to get min() and max() together, database will read full table, and hence cost is 8 times. This is coz we have 2 aggregate functions in our query. Bad - select min(), max() from mytable; Good - select * FROM (select min() from mytable) min_cust, (select max() from mytable) max_cust; Tip 23 : Views Simple view = view created from single table. Complex view = view created by using multiple tables. Some suggestions w.r.t. views- 1. If you don\u2019t need to use all the tables in a view, then don\u2019t use the view. Instead use the actual tables. Otherwise, server will have to join all tables, do aggregation etc on them for a view. i.e. use view for the purpose for which it was created. 2. Else create another view. 3. Don\u2019t join complex views with a table or another view - This is because most of the times view is first executed completely at first, and then result is used as row source to other table or view. So, in this case you be reading lots of unnecessary data and performing unnecessary join and group by. This will increase cost a lot. 4. Avoid performing outer join to the views \u2013 because if you use equality predicate on view column, the optimizer gets wrong if the table of that column has an outer join in the view as well. Because outer join may not know performance of view and may lead to bad execution as well. E.g. \u2013 if we do outer join, optimizer may not be able to push predicate inside the view definition at times of execution plan. Materialized Views- Unlike basic and complex views, materialized views store both query and data. Materialized view data can be refreshed manually or via auto-refresh. But materialized view maintenance is a burden to database \u2013 it needs to be kept up to date for each modification on each change. As compared to normal views, materialized view will improve performance as we will select data directly from materialized view, and there will be no sorts, joins etc. We can create index, partitions etc on materialized view like in an ordinary table. Summary \u2022 If you don\u2019t need to use all the tables in a view, then don\u2019t use the view. Instead use the actual tables. \u2022 Don\u2019t join complex views with a table or another view. \u2022 Avoid performing outer join to the views. \u2022 Use Materialized View - Unlike basic and complex views, materialized views store both query and data. Materialized view data can be refreshed manually or via auto-refresh. But materialized view maintenance is a burden to database . Tip 24: Frequent commit is not desired make REDO logs bulky as we may be committing prior to period. make lock on modified rows, making them unavailable to other applications. Tip 25: Multitable DML operations (skip for big data) Sometimes we have to read same table as input to different tables in our data warehouse. So, if we have 5 different tables requiring input from 1 table, we should ideally be reading input table just once, and keep on feeding into different output tables as per requirements. For this we have 2 options \u2013 \u2022 INSERT ALL \u2022 MERGE INTO","title":"SQL Performance Tuning : Summary"},{"location":"SQL/docs/sql_performance_tuning/#sql-performance-tuning-summary","text":"","title":"SQL Performance Tuning : Summary"},{"location":"SQL/docs/sql_performance_tuning/#tip-1-never-use-star-to-fetch-all-records-from-table","text":"Sql query become fast if you use actual columns instead of * to fetch all the records from the table. Not Recommended - Select * from Employee; Recommended Select Eno,Ename,Address from Employee;","title":"Tip 1: Never use *(Star) to fetch all records from table"},{"location":"SQL/docs/sql_performance_tuning/#tip-2-try-to-avoid-distinct-keyword-from-the-query","text":"Try to avoid DISTINCT keyword from select statements. DISTINCT keyword has high cost and low performance. When anyone uses DISTINCT keyword, it first SORTS the data from column and then fetches the distinct values. Use EXISTS operator instead of DISTINCT keyword. Not Recommended: SELECT DISTINCT d.dept_no, d.department_name FROM Department d,Employee e WHERE d.dept_no= e.dept_no; Recommended: SELECT d.dept_no, d.department_name FROM Department d WHERE EXISTS ( SELECT \u2018X\u2019 FROM Employee e WHERE d.dept_no= e.dept_no);","title":"Tip 2: Try to avoid DISTINCT keyword from the query"},{"location":"SQL/docs/sql_performance_tuning/#tip-3-carefully-use-where-conditions-in-sql","text":"Try to use correct operator as per requirement given. Not Recommended: Select * from Employee WHERE salary != 65000; Recommended: Select * from Employee WHERE salary > 65000 and salary < 65000;","title":"Tip 3: Carefully use WHERE conditions in sql"},{"location":"SQL/docs/sql_performance_tuning/#tip-4-use-like-operator-instead-of-equal-to","text":"Not Recommended: Select * from Employee where name=\u2019Amit\u2019; Recommended: Select * from Employee where name like \u2018Amit%\u2019;","title":"Tip 4: Use Like operator instead of equal to (=)"},{"location":"SQL/docs/sql_performance_tuning/#tip-5-avoid-having-clausegroup-by-statements","text":"HAVING clause and GROUP BY statements have high cost. So try to avoid it in sql query. Not Recommended - Select * from Employee WHERE name=\u2019Amit\u2019 GROUP BY department HAVING salary=45000; Recommended - Select * from Employee WHERE name=\u2019Amit\u2019 and salary=45000; More added: - Having clause- We use Having clause to eliminate some of the group values. Issue \u2013 Having clause restricts the rows AFTER they are read. So if no restriction in \u201cwhere clause\u201d, optimizer will use full table scan. This is really important coz all predicates in the HAVING Clause will not be used as access predicates. So they will not make optimizer use indexes, partitions etc. This is because to perform HAVING clause, it first reads all the rows and then eliminates unnecessary rows.","title":"Tip 5: Avoid HAVING clause/GROUP BY statements"},{"location":"SQL/docs/sql_performance_tuning/#tip-6-use-of-exists-and-in-operators","text":"Basically, Operator IN has lowest performance. IN operator is used when Filter criteria is in subquery, whereas EXISTS operator is used when filter criteria is in main query. Example: IN Operator Select * from Employee where Department_name IN ( Select Department_name from Department where Dno=10); Exist operator Select * from Employee where EXISTS ( Select Department_name from Department where Dno=10); More added When you run a query with IN clause, database will process it in below format \u2013 That is, in case of use of IN clause, each value of sub query is joined with outer query. Treats below Query - select * from T1 where x in (select x from T2); as - select * from t1, (select x from t2) T2 where t1.x = t2.x; But when you use EXIST clause, database will exit as soon as it gets the first match . So, in case of EXIST clause it runs executes query in below format \u2013 Treats below query - select * from T1 where exists (select x from T2 where t1.x=t2.x); as - FOR x IN (select * from t1) LOOP IF (EXISTS ( SELECT X FROM T2) ) THEN OUTPUT THE RECORD END IF; END; That is, using EXIST clause will imply database will run it like a FOR loop and as soon as match is found, it moves to next record. So which one is faster \u2013 IN or EXIST? a. This totally depends on situation. Use IN when - outer table = Big and Subquery = Small Use EXISTS when \u2013 outer table = Small and Subquery = Big b. Even above rules are not fixed. For example, if subquery has bigger table, but it has an index, in this case use of IN is suggested. c. So- EXISTS doesn\u2019t work better than IN all the times. IN is better than EXISTS if \u2013 outer table = Big and Subquery = Small outer table = Small and Subquery = Big + Indexed NOT EXISTS vs NOT IN \u2022 NOT EXISTS is not equivalent of NOT IN. \u2022 NOT EXISTS cannot be used instead of NOT IN all the times. \u2022 More specifically, if there is any NULL value in your data, they will show different result. \u2022 If your subquery returns even one NULL value, NOT IN will not match any rows. \u2022 On other hand, if you have a chance to use NOT EXISTS instead of NOT IN, you should test it. \u2022 In most database versions of oracle, EXISTS and IN are treated similarly in terms of execution plan.","title":"Tip 6: Use of EXISTS and IN Operators"},{"location":"SQL/docs/sql_performance_tuning/#tip-7-try-to-use-union-all-instead-of-union","text":"UNION scans all data first and then eliminate duplicate so it has slow performance. Not Recommended Select * from Employee where dept_no=10 UNION Select * from Employee where dept_no=20; Recommended Select * from Employee where dept_no=10 UNION ALL Select * from Employee where dept_no=20;","title":"Tip 7: Try to use UNION ALL instead of UNION"},{"location":"SQL/docs/sql_performance_tuning/#tip-8-avoid-use-of-functions-in-where-condition","text":"Not Recommended Select * from Employee where Substr(name,1,3)=\u2019Ami\u2019; Recommended Select * from Employee where name like \u2018Ami%\u2019;","title":"Tip 8: Avoid use of Functions in Where condition."},{"location":"SQL/docs/sql_performance_tuning/#tip-9-convert-or-to-and","text":"If we use OR clause, it will PREVENT index usages. Instead, we should use AND where possible. Not Recommended select * from sales where prod_id = 13 or promo_id=14; Recommended select * from sales where prod_id = 13 UNION All select * from sales where promo_id=14 AND prod_id <> 13;","title":"Tip 9: convert OR to AND"},{"location":"SQL/docs/sql_performance_tuning/#tip-10-subquery-unnesting","text":"Nested queries are very costly, and so transformer tries to convert them to equivalent join statements. Not Recommended select * from sales where cust_id IN (select cust_id from customers); Recommended select sales.* from sales, customers where sales.cust_id=customers.cust_id;","title":"Tip 10: Subquery Unnesting"},{"location":"SQL/docs/sql_performance_tuning/#tip-11-in-and-between","text":"select * from employees where emp_id in (2,3,4,5); The above is equivalent to select * from employees where emp_id = 2 OR emp_id=3 OR emp_id=4 OR emp_id=5 ---this implies full table scan. Solution - select * from employees where emp_id between 2 and 5;","title":"Tip 11: IN and BETWEEN"},{"location":"SQL/docs/sql_performance_tuning/#tip-12-fetching-first-n-records","text":"Suppose we want to see only 10 records in our select statement output. There are 2 ways to do this \u2013 Using rownum (Recommended) SELECT * FROM EMPLOYEE where rownum<11; Using fetch first (not recommended) SELECT * FROM EMPLOYEE FETCH FIRST 10 ROWS ONLY; In case of rownum- Here it reads first 10 rows use count STOPKEY operator, and so faster than fetch first method. In case of fetch first \u2013 Here we read whole table, and then applied a windowing function to select 1st 10 records.","title":"Tip 12: Fetching first N records"},{"location":"SQL/docs/sql_performance_tuning/#tip-13-union-vs-union-all","text":"UNION \u2013 combines data and drops duplicate rows. UNION ALL \u2013 combines data and retains duplicate rows. Suggest: Some key points- \u2022 by default, UNION ALL is less costly than UNION, as latter sorts data internally to remove duplicates. \u2022 But if your table is indexed, then sort operation in UNION wont be that costly, and so you can use UNION also. So \u2013 - Use UNION if table is indexed and you don\u2019t want duplicates in output. - Use UNION ALL if\u2013 - There is no duplicate in your data, or - You are ok with having duplicate data in output. - But overall, UNION ALL gives better performance than UNION.","title":"Tip 13: UNION vs UNION ALL:"},{"location":"SQL/docs/sql_performance_tuning/#tip-14-intersect-vs-exists-operator","text":"Intersect gives common rows of 2 intersection in a Sorted order. As part of intersect, 2 rows sources are first sorted, and then common records are fetched. In place of INTERSECT operator, we should try and use EXISTS clause, which is more efficient. One caveat is that, in case of EXISTS clause, output is not sorted, unlike in case of INTERSECT clause. Not Recommended SELECT employee_id FROM employees where employee_id between 145 and 179 INTERSECT SELECT employee_id FROM employees WHERE first_name LIKE 'A%'; Recommended SELECT employee_id FROM employees e where employee_id between 145 and 179 and exists (SELECT employee_id FROM employees t WHERE first_name LIKE 'A%' and e.employee_id = t.employee_id);","title":"Tip 14: INTERSECT Vs EXISTS operator"},{"location":"SQL/docs/sql_performance_tuning/#tip-15-minus-vs-not-exists","text":"MINUS operator eliminates matched rows of 1st (with 2nd) and returns rest of the rows of 1st. NOT EXISTS clause can also do same work as MINUS, but has much better performance. Not Recommended SELECT employee_id FROM employees where employee_id between 145 and 179 MINUS SELECT employee_id FROM employees WHERE first_name LIKE 'A%'; Recommended SELECT employee_id FROM employees e where employee_id between 145 and 179 and not exists (SELECT employee_id FROM employees t WHERE first_name LIKE 'A%' and e.employee_id = t.employee_id);","title":"Tip 15: MINUS Vs NOT EXISTS"},{"location":"SQL/docs/sql_performance_tuning/#tip-16-using-like-conditions","text":"To enable use of indexes, avoid use of wild card character at beginning of source text scan. If you are forced to use wild card character at beginning, you can create reverse index, and handle that problem using that index. In this case, when you reverse index, then source text will eliminate use of wild card at beginning. Eg \u2013 Suppose you want to find records where last name ends is \u201chhar\u201d, then create reverse() index on last_name to reverse it and then use condition where reversed last name begins with \u201crahh\u201d. Though reverse() index usage will have cost, but if your column is selective enough, it wont be much cost.","title":"Tip 16: Using Like conditions"},{"location":"SQL/docs/sql_performance_tuning/#tip-17-using-functions-on-indexed-columns-will-suppress-index-usage","text":"Use of function on indexed column will suppress index usage. So, rewrite query to avoid use of function. BAD QUERY select employee_id, first_name, last_name from employees where trunc(hire_date,'YEAR') = '01-JAN-2002'; GOOD: rewritten query select employee_id, first_name, last_name from employees where hire_date between '01-JAN-2002' and '31-DEC-2002'; Eg2 - Bad select * from mytable where substr(emp_name,1,2) = 'Po'; Good select * from mytable where emp_name like 'Po%'; Note - In Spark, we have HashAggregates and SortAggregates. Hash Aggregates are more performant, and work only on mutable data types. That is, if all elements in your Select clause (except those in Group by clause) are mutable types like INT, FLOAT, etc, then spark will use Hash Aggregates. This means, sometimes, for performance gain, we need to apply Function to transform values. See #14 at below link for details https://github.com/kushal-luthra/spark-development/blob/master/notes/spark_opimization.md","title":"Tip 17: Using Functions on Indexed Columns will suppress index usage."},{"location":"SQL/docs/sql_performance_tuning/#tip-18-handling-null-values","text":"Failing to deal with NULL values will lead to unintentional results or performance losses. Why - \u2022B-Tree indexes do not index NULL values. \u2022If there are any NULL values in your indexed columns and you need to get rows which have NULL values, optimizer will not use your index, and perform a full table scan instead. \u2022That is, having Null values in your index may sometimes suppress index usage. Ways to handle NULL value-based performance loss a. Use IS NOT NULL condition in your WHERE clause. Use IS NOT NULL condition in your WHERE clause if you don\u2019t need to have NULL values in result set. That is, even if you now your result will not be having any NULL values, you should use \u201cis not null \u201c clause to make optimizer use indexes. Eg \u2013 Query 1: select emp_name, emp_id from employee where emp_id <> 1; Query 2: select emp_name, emp_id from employee where emp_id <> 1 and emp_id is not null; In query 1, we will see FULL Table scan and in case of query 2, we see index-based scan, and lower query cost. b. Adding not null constraint to your columns and insert a specific value for NULL values like \u20180\u2019 if value in a column is null. c. If reasonable, create a BITMAP index instead of B-Tree index. BITMAP indexes store NULL values. So even if there are null values in our column, optimizer will be able to use our indexes. However, you need to take into consideration index efficiency between B-Tree and BITMAP, as former as more efficient than latter. - We use BITMAP indexes when \u2013 cardinality is LOW and index not modified often. - We use B-Tree index when \u2013 cardinality/selectivity is high.","title":"Tip 18: Handling NULL Values"},{"location":"SQL/docs/sql_performance_tuning/#tip-19-use-truncate-instead-of-delete","text":"Truncate is always faster than DELETE command. This is because when you run delete command, oracle database generates lots of UNDO data for deleted rows and generating UNDO data is an expensive operation. Truncate doesn\u2019t generate UNDO Data. But before using Truncate command, there are few things to note about it- \u2022 No rollback \u2013 Truncate operation cannot be rollbacked, and Flashback is also not so easy after truncate operations. You may need to use Flashback Data Archive or some other external tools in this case. \u2022 Truncate is a DDL operation \u2013 So when you run Truncate, your transaction will be committed. It performs commit before and after Truncate operation. Since it does 2 commits, and even if truncate operation fails in between, the changes you did before will be permanent in any case. \u2022 Truncate a partition - We don\u2019t need to truncate whole table all the times. You can truncate partition as well. \u2022 Truncate doesn\u2019t fire DML triggers - So you wont be able to log your truncate operation because of that. But it can fire the DDL triggers. \u2022 Truncate makes unusable indexes usable again. But delete does not.","title":"Tip 19 : Use Truncate instead of Delete"},{"location":"SQL/docs/sql_performance_tuning/#tip-20-data-type-mismatches","text":"If data types of column and compared value dont match, this may suppress index usage. select cust_id, cust_code from customers where cust_code = 101; Vs select cust_id, cust_code from customers where cust_code = '101';","title":"Tip 20: Data Type Mismatches"},{"location":"SQL/docs/sql_performance_tuning/#tip-21-tuning-ordered-queries-order-by-clause","text":"Order by mostly requires SORT operations . This sort operation is done in PGA or in disk (if PGA doesn\u2019t have enough memory) This disk is shown as \u2018temporary table space\u2019 in execution plan. Issue \u2013 sorting in disk is a costly operation. Solution \u2013 \u2022 Create a B-Tree index on column used in Order by Clause, or \u2022 Modify a B-Tree index to include column used in Order by Clause. \u2022 Why\u2013> B-Tree indexes store columns in Order and using B-Tree index will eliminate sort operations.","title":"Tip 21: Tuning Ordered queries- Order By clause"},{"location":"SQL/docs/sql_performance_tuning/#tip-22-retrieving-min-and-max-values","text":"B-Tree indexes increase the performance a lot for min and max value searches. If no B-Tree index, optimizer will need to read whole table. If our query has another column or another aggregate function in your query, it will be reading whole index or whole table. For example- When you see below, if we are looking for min() and max() values individually, output is just 2 for each. But when we want to get min() and max() together, database will read full table, and hence cost is 8 times. This is coz we have 2 aggregate functions in our query. Bad - select min(), max() from mytable; Good - select * FROM (select min() from mytable) min_cust, (select max() from mytable) max_cust;","title":"Tip 22 : Retrieving MIN and MAX Values"},{"location":"SQL/docs/sql_performance_tuning/#tip-23-views","text":"Simple view = view created from single table. Complex view = view created by using multiple tables. Some suggestions w.r.t. views- 1. If you don\u2019t need to use all the tables in a view, then don\u2019t use the view. Instead use the actual tables. Otherwise, server will have to join all tables, do aggregation etc on them for a view. i.e. use view for the purpose for which it was created. 2. Else create another view. 3. Don\u2019t join complex views with a table or another view - This is because most of the times view is first executed completely at first, and then result is used as row source to other table or view. So, in this case you be reading lots of unnecessary data and performing unnecessary join and group by. This will increase cost a lot. 4. Avoid performing outer join to the views \u2013 because if you use equality predicate on view column, the optimizer gets wrong if the table of that column has an outer join in the view as well. Because outer join may not know performance of view and may lead to bad execution as well. E.g. \u2013 if we do outer join, optimizer may not be able to push predicate inside the view definition at times of execution plan. Materialized Views- Unlike basic and complex views, materialized views store both query and data. Materialized view data can be refreshed manually or via auto-refresh. But materialized view maintenance is a burden to database \u2013 it needs to be kept up to date for each modification on each change. As compared to normal views, materialized view will improve performance as we will select data directly from materialized view, and there will be no sorts, joins etc. We can create index, partitions etc on materialized view like in an ordinary table. Summary \u2022 If you don\u2019t need to use all the tables in a view, then don\u2019t use the view. Instead use the actual tables. \u2022 Don\u2019t join complex views with a table or another view. \u2022 Avoid performing outer join to the views. \u2022 Use Materialized View - Unlike basic and complex views, materialized views store both query and data. Materialized view data can be refreshed manually or via auto-refresh. But materialized view maintenance is a burden to database .","title":"Tip 23 : Views"},{"location":"SQL/docs/sql_performance_tuning/#tip-24-frequent-commit-is-not-desired","text":"make REDO logs bulky as we may be committing prior to period. make lock on modified rows, making them unavailable to other applications.","title":"Tip 24: Frequent commit is not desired"},{"location":"SQL/docs/sql_performance_tuning/#tip-25-multitable-dml-operations-skip-for-big-data","text":"Sometimes we have to read same table as input to different tables in our data warehouse. So, if we have 5 different tables requiring input from 1 table, we should ideally be reading input table just once, and keep on feeding into different output tables as per requirements. For this we have 2 options \u2013 \u2022 INSERT ALL \u2022 MERGE INTO","title":"Tip 25: Multitable DML operations (skip for big data)"},{"location":"SQL/docs/sql_performance_tuning_summary/","text":"SQL Performance Tuning : Summary Tip 1: Never use *(Star) to fetch all records from table Tip 2: Try to avoid DISTINCT keyword from the query Not Recommended: SELECT DISTINCT d.dept_no, d.department_name FROM Department d,Employee e WHERE d.dept_no= e.dept_no; Recommended: SELECT d.dept_no d.department_name FROM Department d WHERE EXISTS ( SELECT \u2018X\u2019 FROM Employee e WHERE d.dept_no= e.dept_no); Tip 3: Carefully use WHERE conditions in sql. Tip 4: Use Like operator instead of equal to (=) Tip 5: Avoid HAVING clause/GROUP BY statements Tip 6: Use of EXISTS and IN Operators Tip 7: Try to use UNION ALL instead of UNION as UNION scans all data first and then eliminate duplicate so it has slow performance. Tip 9: convert OR to AND Tip 10: Subquery Unnesting Tip 11: IN and BETWEEN Tip 12: Fetching first N records: SELECT * FROM EMPLOYEE where rownum<11 Tip 13: UNION vs UNION ALL: \u2022 by default, UNION ALL is less costly than UNION, as latter sorts data internally to remove duplicates. \u2022 But if your table is indexed, then sort operation in UNION wont be that costly, and so you can use UNION also. Tip 14: INTERSECT Vs EXISTS operator Tip 15: MINUS Vs NOT EXISTS Tip 16: Using Like conditions To enable use of indexes, avoid use of wild card character at beginning of source text scan. If you are forced to use wild card character at beginning, you can create reverse index, and handle that problem using that index. In this case, when you reverse index, then source text will eliminate use of wild card at beginning. Tip 17: Using Functions on Indexed Columns will suppress index usage. So, rewrite query to avoid use of function. BAD QUERY select employee_id, first_name, last_name from employees where trunc(hire_date,'YEAR') = '01-JAN-2002'; GOOD: rewritten query select employee_id, first_name, last_name from employees where hire_date between '01-JAN-2002' and '31-DEC-2002'; Eg2 - Bad select * from mytable where substr(emp_name,1,2) = 'Po'; Good select * from mytable where emp_name like 'Po%'; Tip 18: Handling NULL Values \u2022B-Tree indexes do not index NULL values. \u2022If there are any NULL values in your indexed columns and you need to get rows which have NULL values, optimizer will not use your index, and perform a full table scan instead. \u2022That is, having Null values in your index may sometimes suppress index usage. Solution - - Use IS NOT NULL condition in your WHERE clause. - Adding not null constraint to your columns and insert a specific value for NULL values like \u20180\u2019 if value in a column is null. - If reasonable, create a BITMAP index instead of B-Tree index. Tip 19 : Use Truncate instead of Delete Tip 20: Data Type Mismatches If data types of column and compared value dont match, this may suppress index usage. Tip 21: Tuning Ordered queries- Order By clause Order by mostly requires sort operations. This sort operation is done in PGA or in disk (if PGA doesn\u2019t have enough memory) This disk is shown as \u2018temporary table space\u2019 in execution plan. Issue \u2013 sorting in disk is a costly operation. Solution \u2013 \u2022 Create a B-Tree index on column used in Order by Clause, or \u2022 Modify a B-Tree index to include column used in Order by Clause. \u2022 Why \u2013 B-Tree indexes store columns in Order and using B-Tree index will eliminate sort operations. Tip 22 : Retrieving MIN and MAX Values B-Tree indexes increase the performance a lot for min and max value searches. If no B-Tree index, optimizer will need to read whole table. Bad - select min(), max() from mytable; Good - select * FROM (select min() from mytable) min_cust, (select max() from mytable) max_cust; Tip 23 : Views \u2022 If you don\u2019t need to use all the tables in a view, then don\u2019t use the view. Instead use the actual tables. \u2022 Don\u2019t join complex views with a table or another view. \u2022 Avoid performing outer join to the views. \u2022 Unlike basic and complex views, materialized views store both query and data. Materialized view data can be refreshed manually or via auto-refresh. But materialized view maintenance is a burden to database . Tip 24: Frequent commit is not desired: make REDO logs bulky as we may be committing prior to period. make lock on modified rows, making them unavailable to other applications.","title":"SQL Performance Tuning Summary"},{"location":"SQL/docs/sql_performance_tuning_summary/#sql-performance-tuning-summary","text":"","title":"SQL Performance Tuning : Summary"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-1-never-use-star-to-fetch-all-records-from-table","text":"","title":"Tip 1: Never use *(Star) to fetch all records from table"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-2-try-to-avoid-distinct-keyword-from-the-query","text":"Not Recommended: SELECT DISTINCT d.dept_no, d.department_name FROM Department d,Employee e WHERE d.dept_no= e.dept_no; Recommended: SELECT d.dept_no d.department_name FROM Department d WHERE EXISTS ( SELECT \u2018X\u2019 FROM Employee e WHERE d.dept_no= e.dept_no);","title":"Tip 2: Try to avoid DISTINCT keyword from the query "},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-3-carefully-use-where-conditions-in-sql","text":"","title":"Tip 3: Carefully use WHERE conditions in sql. "},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-4-use-like-operator-instead-of-equal-to","text":"","title":"Tip 4: Use Like operator instead of equal to (=)"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-5-avoid-having-clausegroup-by-statements","text":"","title":"Tip 5: Avoid HAVING clause/GROUP BY statements"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-6-use-of-exists-and-in-operators","text":"","title":"Tip 6: Use of EXISTS and IN Operators"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-7-try-to-use-union-all-instead-of-union-as-union-scans-all-data-first-and-then-eliminate-duplicate-so-it-has-slow-performance","text":"","title":"Tip 7: Try to use UNION ALL instead of UNION as UNION scans all data first and then eliminate duplicate so it has slow performance."},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-9-convert-or-to-and","text":"","title":"Tip 9: convert OR to AND"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-10-subquery-unnesting","text":"","title":"Tip 10: Subquery Unnesting"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-11-in-and-between","text":"","title":"Tip 11: IN and BETWEEN"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-12-fetching-first-n-records-select-from-employee-where-rownum11","text":"","title":"Tip 12: Fetching first N records:  SELECT * FROM EMPLOYEE where rownum&lt;11"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-13-union-vs-union-all","text":"\u2022 by default, UNION ALL is less costly than UNION, as latter sorts data internally to remove duplicates. \u2022 But if your table is indexed, then sort operation in UNION wont be that costly, and so you can use UNION also.","title":"Tip 13: UNION vs UNION ALL:"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-14-intersect-vs-exists-operator","text":"","title":"Tip 14: INTERSECT Vs EXISTS operator"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-15-minus-vs-not-exists","text":"","title":"Tip 15: MINUS Vs NOT EXISTS"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-16-using-like-conditions","text":"To enable use of indexes, avoid use of wild card character at beginning of source text scan. If you are forced to use wild card character at beginning, you can create reverse index, and handle that problem using that index. In this case, when you reverse index, then source text will eliminate use of wild card at beginning.","title":"Tip 16: Using Like conditions"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-17-using-functions-on-indexed-columns-will-suppress-index-usage","text":"So, rewrite query to avoid use of function. BAD QUERY select employee_id, first_name, last_name from employees where trunc(hire_date,'YEAR') = '01-JAN-2002'; GOOD: rewritten query select employee_id, first_name, last_name from employees where hire_date between '01-JAN-2002' and '31-DEC-2002'; Eg2 - Bad select * from mytable where substr(emp_name,1,2) = 'Po'; Good select * from mytable where emp_name like 'Po%';","title":"Tip 17: Using Functions on Indexed Columns will suppress index usage."},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-18-handling-null-values","text":"\u2022B-Tree indexes do not index NULL values. \u2022If there are any NULL values in your indexed columns and you need to get rows which have NULL values, optimizer will not use your index, and perform a full table scan instead. \u2022That is, having Null values in your index may sometimes suppress index usage. Solution - - Use IS NOT NULL condition in your WHERE clause. - Adding not null constraint to your columns and insert a specific value for NULL values like \u20180\u2019 if value in a column is null. - If reasonable, create a BITMAP index instead of B-Tree index.","title":"Tip 18: Handling NULL Values"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-19-use-truncate-instead-of-delete","text":"","title":"Tip 19 : Use Truncate instead of Delete"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-20-data-type-mismatches","text":"If data types of column and compared value dont match, this may suppress index usage.","title":"Tip 20: Data Type Mismatches"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-21-tuning-ordered-queries-order-by-clause","text":"Order by mostly requires sort operations. This sort operation is done in PGA or in disk (if PGA doesn\u2019t have enough memory) This disk is shown as \u2018temporary table space\u2019 in execution plan. Issue \u2013 sorting in disk is a costly operation. Solution \u2013 \u2022 Create a B-Tree index on column used in Order by Clause, or \u2022 Modify a B-Tree index to include column used in Order by Clause. \u2022 Why \u2013 B-Tree indexes store columns in Order and using B-Tree index will eliminate sort operations.","title":"Tip 21: Tuning Ordered queries- Order By clause"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-22-retrieving-min-and-max-values","text":"B-Tree indexes increase the performance a lot for min and max value searches. If no B-Tree index, optimizer will need to read whole table. Bad - select min(), max() from mytable; Good - select * FROM (select min() from mytable) min_cust, (select max() from mytable) max_cust;","title":"Tip 22 : Retrieving MIN and MAX Values"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-23-views","text":"\u2022 If you don\u2019t need to use all the tables in a view, then don\u2019t use the view. Instead use the actual tables. \u2022 Don\u2019t join complex views with a table or another view. \u2022 Avoid performing outer join to the views. \u2022 Unlike basic and complex views, materialized views store both query and data. Materialized view data can be refreshed manually or via auto-refresh. But materialized view maintenance is a burden to database .","title":"Tip 23 : Views"},{"location":"SQL/docs/sql_performance_tuning_summary/#tip-24-frequent-commit-is-not-desired","text":"make REDO logs bulky as we may be committing prior to period. make lock on modified rows, making them unavailable to other applications.","title":"Tip 24: Frequent commit is not desired:"}]}